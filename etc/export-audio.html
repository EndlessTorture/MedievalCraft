<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Export Audio</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        .audio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .audio-item {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
        }
        .audio-item h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #3282b8;
        }
        .audio-item .category {
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
        }
        .audio-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 5px 0;
        }
        .waveform {
            width: 120px;
            height: 40px;
            background: #0f3460;
            border-radius: 4px;
        }
        button {
            background: #3282b8;
            color: white;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }
        button:hover { background: #0f4c75; }
        button:disabled { background: #444; cursor: not-allowed; }
        .play-btn { background: #27ae60; }
        .play-btn:hover { background: #1e8449; }
        .download-all {
            background: #27ae60;
            font-size: 18px;
            padding: 15px 30px;
            margin: 10px 5px;
        }
        .download-all:hover { background: #1e8449; }
        .instructions {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .instructions code {
            background: #1a1a2e;
            padding: 2px 6px;
            border-radius: 3px;
        }
        .progress {
            margin: 10px 0;
            padding: 10px;
            background: #0f3460;
            border-radius: 5px;
            display: none;
        }
        .progress-bar {
            height: 20px;
            background: #27ae60;
            border-radius: 3px;
            width: 0%;
            transition: width 0.2s;
        }
        .progress-text {
            margin-top: 5px;
            font-size: 12px;
        }
        .format-select {
            margin: 10px 0;
        }
        .format-select label {
            margin-right: 15px;
        }
    </style>
</head>
<body>
<h1>ğŸ”Š Audio Exporter</h1>

<div class="instructions">
    <h3>Instructions:</h3>
    <ol>
        <li>Click "â–¶" to preview any sound</li>
        <li>Click "Download All" to get a ZIP with all audio files</li>
        <li>Or click individual "Save" buttons to download specific sounds</li>
        <li>Place the audio files in <code>assets/audio/</code> folder structure</li>
    </ol>
</div>

<div class="format-select">
    <strong>Format:</strong>
    <label><input type="radio" name="format" value="wav" checked> WAV (better quality)</label>
    <label><input type="radio" name="format" value="ogg"> OGG (smaller size, requires encoding)</label>
</div>

<button class="download-all" onclick="downloadAll()">ğŸ“¦ Download All Audio (ZIP)</button>
<button class="download-all" style="background:#3282b8" onclick="playAllPreview()">ğŸ”Š Preview All Sounds</button>

<div class="progress" id="progress">
    <div class="progress-bar" id="progressBar"></div>
    <div class="progress-text" id="progressText">Generating...</div>
</div>

<div id="audio" class="audio-grid"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    // â”€â”€ ĞÑƒĞ´Ğ¸Ğ¾ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const SAMPLE_RATE = 44100;

    // â”€â”€ Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function makeNoiseBuffer(duration, decay = 5, sampleRate = SAMPLE_RATE) {
        const length = sampleRate * duration | 0;
        const buffer = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            buffer[i] = (Math.random() * 2 - 1) * Math.exp(-i / length * decay);
        }
        return buffer;
    }

    function applyBandpass(buffer, freq, Q, sampleRate = SAMPLE_RATE) {
        // ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ğ±Ğ¸ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€
        const w0 = 2 * Math.PI * freq / sampleRate;
        const alpha = Math.sin(w0) / (2 * Q);
        const b0 = alpha, b1 = 0, b2 = -alpha;
        const a0 = 1 + alpha, a1 = -2 * Math.cos(w0), a2 = 1 - alpha;

        const output = new Float32Array(buffer.length);
        let x1 = 0, x2 = 0, y1 = 0, y2 = 0;

        for (let i = 0; i < buffer.length; i++) {
            const x0 = buffer[i];
            output[i] = (b0/a0)*x0 + (b1/a0)*x1 + (b2/a0)*x2 - (a1/a0)*y1 - (a2/a0)*y2;
            x2 = x1; x1 = x0;
            y2 = y1; y1 = output[i];
        }
        return output;
    }

    function applyLowpass(buffer, freq, sampleRate = SAMPLE_RATE) {
        const rc = 1 / (2 * Math.PI * freq);
        const dt = 1 / sampleRate;
        const alpha = dt / (rc + dt);

        const output = new Float32Array(buffer.length);
        output[0] = buffer[0];
        for (let i = 1; i < buffer.length; i++) {
            output[i] = output[i-1] + alpha * (buffer[i] - output[i-1]);
        }
        return output;
    }

    function applyHighpass(buffer, freq, sampleRate = SAMPLE_RATE) {
        const rc = 1 / (2 * Math.PI * freq);
        const dt = 1 / sampleRate;
        const alpha = rc / (rc + dt);

        const output = new Float32Array(buffer.length);
        output[0] = buffer[0];
        for (let i = 1; i < buffer.length; i++) {
            output[i] = alpha * (output[i-1] + buffer[i] - buffer[i-1]);
        }
        return output;
    }

    function generateSine(freq, duration, freqEnd = null, sampleRate = SAMPLE_RATE) {
        const length = sampleRate * duration | 0;
        const buffer = new Float32Array(length);
        let phase = 0;

        for (let i = 0; i < length; i++) {
            const t = i / length;
            const currentFreq = freqEnd ? freq * Math.pow(freqEnd / freq, t) : freq;
            buffer[i] = Math.sin(phase);
            phase += 2 * Math.PI * currentFreq / sampleRate;
        }
        return buffer;
    }

    function applyEnvelope(buffer, attack = 0.01, decay = 0.1, sustain = 0.5, release = 0.2) {
        const length = buffer.length;
        const attackSamples = length * attack | 0;
        const decaySamples = length * decay | 0;
        const releaseSamples = length * release | 0;
        const sustainSamples = length - attackSamples - decaySamples - releaseSamples;

        for (let i = 0; i < length; i++) {
            let gain = 1;
            if (i < attackSamples) {
                gain = i / attackSamples;
            } else if (i < attackSamples + decaySamples) {
                gain = 1 - (1 - sustain) * (i - attackSamples) / decaySamples;
            } else if (i >= length - releaseSamples) {
                gain = sustain * (1 - (i - (length - releaseSamples)) / releaseSamples);
            } else {
                gain = sustain;
            }
            buffer[i] *= gain;
        }
        return buffer;
    }

    function applyFadeOut(buffer, startRatio = 0) {
        const start = buffer.length * startRatio | 0;
        for (let i = start; i < buffer.length; i++) {
            const t = (i - start) / (buffer.length - start);
            buffer[i] *= Math.exp(-t * 5);
        }
        return buffer;
    }

    function mixBuffers(...buffers) {
        const maxLen = Math.max(...buffers.map(b => b.length));
        const output = new Float32Array(maxLen);
        for (const buf of buffers) {
            for (let i = 0; i < buf.length; i++) {
                output[i] += buf[i];
            }
        }
        // ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
        let max = 0;
        for (let i = 0; i < output.length; i++) max = Math.max(max, Math.abs(output[i]));
        if (max > 1) for (let i = 0; i < output.length; i++) output[i] /= max;
        return output;
    }

    function addDelay(buffer, delaySamples, mix = 0.3) {
        const output = new Float32Array(buffer.length + delaySamples);
        for (let i = 0; i < buffer.length; i++) {
            output[i] += buffer[i];
            output[i + delaySamples] += buffer[i] * mix;
        }
        return output;
    }

    function pitchShift(buffer, factor) {
        const newLen = buffer.length / factor | 0;
        const output = new Float32Array(newLen);
        for (let i = 0; i < newLen; i++) {
            const srcIdx = i * factor;
            const idx0 = srcIdx | 0;
            const frac = srcIdx - idx0;
            output[i] = buffer[idx0] * (1 - frac) + (buffer[idx0 + 1] || 0) * frac;
        }
        return output;
    }

    // â”€â”€ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ·Ğ²ÑƒĞºĞ¾Ğ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const SOUND_GENERATORS = {
        // Ğ‘Ğ»Ğ¾ĞºĞ¸
        'blocks/stone': (variation) => {
            const seed = variation * 12345;
            const freq = 150 + (seed % 80);
            let buf = makeNoiseBuffer(0.25, 5 + (seed % 3));
            buf = applyBandpass(buf, freq, 1.5);
            applyFadeOut(buf);

            // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ ÑĞ»Ğ¾Ğ¹
            let buf2 = makeNoiseBuffer(0.08, 15);
            buf2 = applyBandpass(buf2, 300, 2);
            for (let i = 0; i < buf2.length; i++) buf2[i] *= 0.4;

            return mixBuffers(buf, buf2);
        },

        'blocks/dirt': (variation) => {
            const seed = variation * 54321;
            const freq = 100 + (seed % 60);
            let buf = makeNoiseBuffer(0.18, 7 + (seed % 3));
            buf = applyBandpass(buf, freq, 2);
            applyFadeOut(buf);
            return buf;
        },

        'blocks/grass': (variation) => {
            const seed = variation * 11111;
            const freq = 500 + (seed % 400);
            let buf = makeNoiseBuffer(0.16, 9 + (seed % 4));
            buf = applyBandpass(buf, freq, 3);
            applyFadeOut(buf);

            // ĞĞ¸Ğ·ĞºĞ¾Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğ½Ñ‹Ğ¹ ÑĞ»Ğ¾Ğ¹
            let buf2 = makeNoiseBuffer(0.1, 12);
            buf2 = applyLowpass(buf2, 200);
            for (let i = 0; i < buf2.length; i++) buf2[i] *= 0.3;

            return mixBuffers(buf, buf2);
        },

        'blocks/wood': (variation) => {
            const seed = variation * 22222;
            const freq = 220 + (seed % 120);
            let buf = makeNoiseBuffer(0.22, 6 + (seed % 3));
            buf = applyBandpass(buf, freq, 2);
            applyFadeOut(buf);

            // Ğ¢Ñ€ĞµÑĞº
            let buf2 = makeNoiseBuffer(0.12, 8);
            buf2 = applyBandpass(buf2, 350, 1.5);
            for (let i = 0; i < buf2.length; i++) buf2[i] *= 0.5;
            buf2 = addDelay(buf2, (0.05 * SAMPLE_RATE) | 0, 0.4);

            return mixBuffers(buf, buf2);
        },

        'blocks/leaves': (variation) => {
            const seed = variation * 33333;
            const freq = 1000 + (seed % 800);
            let buf = makeNoiseBuffer(0.22, 7 + (seed % 4));
            buf = applyBandpass(buf, freq, 4);
            applyFadeOut(buf);

            let buf2 = makeNoiseBuffer(0.15, 10);
            buf2 = applyHighpass(buf2, 600);
            for (let i = 0; i < buf2.length; i++) buf2[i] *= 0.35;

            return mixBuffers(buf, buf2);
        },

        'blocks/sand': (variation) => {
            const seed = variation * 44444;
            const freq = 400 + (seed % 300);
            let buf = makeNoiseBuffer(0.2, 6 + (seed % 3));
            buf = applyBandpass(buf, freq, 4);
            applyFadeOut(buf);
            return buf;
        },

        'blocks/gravel': (variation) => {
            const seed = variation * 55555;
            const freq = 180 + (seed % 100);
            let buf = makeNoiseBuffer(0.24, 5 + (seed % 3));
            buf = applyBandpass(buf, freq, 2);
            applyFadeOut(buf);

            let buf2 = makeNoiseBuffer(0.12, 8);
            buf2 = applyBandpass(buf2, 140, 1.5);
            for (let i = 0; i < buf2.length; i++) buf2[i] *= 0.4;
            buf2 = addDelay(buf2, (0.04 * SAMPLE_RATE) | 0, 0.3);

            return mixBuffers(buf, buf2);
        },

        'blocks/snow': (variation) => {
            const seed = variation * 66666;
            const freq = 700 + (seed % 400);
            let buf = makeNoiseBuffer(0.16, 10 + (seed % 4));
            buf = applyBandpass(buf, freq, 5);
            applyFadeOut(buf);
            return buf;
        },

        'blocks/glass': (variation) => {
            const seed = variation * 77777;
            // Ğ¢Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚
            let sine = generateSine(1600 + (seed % 400), 0.35);
            applyEnvelope(sine, 0.001, 0.05, 0.3, 0.6);

            // Ğ¨ÑƒĞ¼Ğ¾Ğ²Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ (Ğ¾ÑĞºĞ¾Ğ»ĞºĞ¸)
            let noise = makeNoiseBuffer(0.2, 7);
            noise = applyHighpass(noise, 1800);
            for (let i = 0; i < noise.length; i++) noise[i] *= 0.4;

            return mixBuffers(sine, noise);
        },

        'blocks/water': (variation) => {
            const seed = variation * 88888;
            let buf = makeNoiseBuffer(0.25, 5);
            buf = applyBandpass(buf, 350 + (seed % 200), 3);
            applyFadeOut(buf);

            // "ĞŸĞ»ÑÑ…"
            let plop = generateSine(300, 0.18, 70);
            applyEnvelope(plop, 0.01, 0.1, 0.2, 0.5);
            for (let i = 0; i < plop.length; i++) plop[i] *= 0.3;

            return mixBuffers(buf, plop);
        },

        // Ğ¨Ğ°Ğ³Ğ¸
        'player/step_stone': (variation) => {
            const seed = variation * 99999;
            let buf = makeNoiseBuffer(0.1, 8 + (seed % 4));
            buf = applyLowpass(buf, 350 + (seed % 200));
            applyFadeOut(buf);
            return buf;
        },

        'player/step_grass': (variation) => {
            const seed = variation * 11223;
            let buf = makeNoiseBuffer(0.12, 10 + (seed % 4));
            buf = applyBandpass(buf, 600 + (seed % 400), 3);
            applyFadeOut(buf);
            return buf;
        },

        'player/step_sand': (variation) => {
            const seed = variation * 33445;
            let buf = makeNoiseBuffer(0.1, 8 + (seed % 3));
            buf = applyBandpass(buf, 500 + (seed % 300), 4);
            applyFadeOut(buf);
            return buf;
        },

        'player/step_wood': (variation) => {
            const seed = variation * 55667;
            let buf = makeNoiseBuffer(0.08, 10 + (seed % 4));
            buf = applyBandpass(buf, 300 + (seed % 150), 2);
            applyFadeOut(buf);

            // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ "ÑÑ‚ÑƒĞº"
            let knock = generateSine(200, 0.05, 100);
            applyEnvelope(knock, 0.001, 0.02, 0.1, 0.3);
            for (let i = 0; i < knock.length; i++) knock[i] *= 0.3;

            return mixBuffers(buf, knock);
        },

        // UI Ğ¸ Ğ¿Ñ€Ğ¾Ñ‡ĞµĞµ
        'player/pickup': (variation) => {
            let sine = generateSine(500 + variation * 50, 0.12, 1100 + variation * 100);
            applyEnvelope(sine, 0.01, 0.02, 0.6, 0.3);
            return sine;
        },

        'player/hit': (variation) => {
            const seed = variation * 77889;
            let buf = makeNoiseBuffer(0.08, 12);
            buf = applyBandpass(buf, 350 + (seed % 200), 2);
            applyFadeOut(buf);

            let impact = generateSine(150, 0.05, 80);
            applyEnvelope(impact, 0.001, 0.02, 0.3, 0.2);
            for (let i = 0; i < impact.length; i++) impact[i] *= 0.4;

            return mixBuffers(buf, impact);
        },

        'ui/click': (variation) => {
            let sine = generateSine(800 + variation * 100, 0.04, 600);
            applyEnvelope(sine, 0.001, 0.01, 0.4, 0.2);
            return sine;
        },
    };

    // â”€â”€ ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ²ÑƒĞºĞ¾Ğ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const SOUNDS = [
        // Ğ‘Ğ»Ğ¾ĞºĞ¸ (3 Ğ²Ğ°Ñ€Ğ¸Ğ°Ñ†Ğ¸Ğ¸ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹)
        { name: 'blocks/stone1', generator: 'blocks/stone', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/stone2', generator: 'blocks/stone', variation: 2, category: 'Block Breaking' },
        { name: 'blocks/stone3', generator: 'blocks/stone', variation: 3, category: 'Block Breaking' },

        { name: 'blocks/dirt1', generator: 'blocks/dirt', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/dirt2', generator: 'blocks/dirt', variation: 2, category: 'Block Breaking' },
        { name: 'blocks/dirt3', generator: 'blocks/dirt', variation: 3, category: 'Block Breaking' },

        { name: 'blocks/grass1', generator: 'blocks/grass', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/grass2', generator: 'blocks/grass', variation: 2, category: 'Block Breaking' },
        { name: 'blocks/grass3', generator: 'blocks/grass', variation: 3, category: 'Block Breaking' },

        { name: 'blocks/wood1', generator: 'blocks/wood', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/wood2', generator: 'blocks/wood', variation: 2, category: 'Block Breaking' },
        { name: 'blocks/wood3', generator: 'blocks/wood', variation: 3, category: 'Block Breaking' },

        { name: 'blocks/leaves1', generator: 'blocks/leaves', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/leaves2', generator: 'blocks/leaves', variation: 2, category: 'Block Breaking' },

        { name: 'blocks/sand1', generator: 'blocks/sand', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/sand2', generator: 'blocks/sand', variation: 2, category: 'Block Breaking' },

        { name: 'blocks/gravel1', generator: 'blocks/gravel', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/gravel2', generator: 'blocks/gravel', variation: 2, category: 'Block Breaking' },

        { name: 'blocks/snow1', generator: 'blocks/snow', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/snow2', generator: 'blocks/snow', variation: 2, category: 'Block Breaking' },

        { name: 'blocks/glass1', generator: 'blocks/glass', variation: 1, category: 'Block Breaking' },
        { name: 'blocks/glass2', generator: 'blocks/glass', variation: 2, category: 'Block Breaking' },

        { name: 'blocks/water1', generator: 'blocks/water', variation: 1, category: 'Block Breaking' },

        // Ğ¨Ğ°Ğ³Ğ¸
        { name: 'player/step_stone1', generator: 'player/step_stone', variation: 1, category: 'Footsteps' },
        { name: 'player/step_stone2', generator: 'player/step_stone', variation: 2, category: 'Footsteps' },
        { name: 'player/step_stone3', generator: 'player/step_stone', variation: 3, category: 'Footsteps' },

        { name: 'player/step_grass1', generator: 'player/step_grass', variation: 1, category: 'Footsteps' },
        { name: 'player/step_grass2', generator: 'player/step_grass', variation: 2, category: 'Footsteps' },
        { name: 'player/step_grass3', generator: 'player/step_grass', variation: 3, category: 'Footsteps' },

        { name: 'player/step_sand1', generator: 'player/step_sand', variation: 1, category: 'Footsteps' },
        { name: 'player/step_sand2', generator: 'player/step_sand', variation: 2, category: 'Footsteps' },

        { name: 'player/step_wood1', generator: 'player/step_wood', variation: 1, category: 'Footsteps' },
        { name: 'player/step_wood2', generator: 'player/step_wood', variation: 2, category: 'Footsteps' },

        // UI Ğ¸ Ğ¸Ğ³Ñ€Ğ¾Ğº
        { name: 'player/pickup', generator: 'player/pickup', variation: 1, category: 'Player' },
        { name: 'player/hit', generator: 'player/hit', variation: 1, category: 'Player' },
        { name: 'ui/click', generator: 'ui/click', variation: 1, category: 'UI' },
    ];

    // â”€â”€ ĞšÑÑˆ ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ±ÑƒÑ„ĞµÑ€Ğ¾Ğ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const audioBuffers = new Map();

    function generateSoundBuffer(sound) {
        const key = sound.name;
        if (audioBuffers.has(key)) return audioBuffers.get(key);

        const generator = SOUND_GENERATORS[sound.generator];
        if (!generator) {
            console.warn('Unknown generator:', sound.generator);
            return null;
        }

        const samples = generator(sound.variation);
        audioBuffers.set(key, samples);
        return samples;
    }

    // â”€â”€ Ğ’Ğ¾ÑĞ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function playSamples(samples, volume = 0.5) {
        const buffer = audioCtx.createBuffer(1, samples.length, SAMPLE_RATE);
        buffer.getChannelData(0).set(samples);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;

        const gain = audioCtx.createGain();
        gain.gain.value = volume;

        source.connect(gain);
        gain.connect(audioCtx.destination);
        source.start();
    }

    // â”€â”€ ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ² WAV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function samplesToWav(samples) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const bytesPerSample = bitsPerSample / 8;
        const blockAlign = numChannels * bytesPerSample;
        const byteRate = SAMPLE_RATE * blockAlign;
        const dataSize = samples.length * bytesPerSample;
        const headerSize = 44;

        const buffer = new ArrayBuffer(headerSize + dataSize);
        const view = new DataView(buffer);

        // RIFF header
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + dataSize, true);
        writeString(view, 8, 'WAVE');

        // fmt chunk
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);           // chunk size
        view.setUint16(20, 1, true);            // audio format (PCM)
        view.setUint16(22, numChannels, true);
        view.setUint32(24, SAMPLE_RATE, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitsPerSample, true);

        // data chunk
        writeString(view, 36, 'data');
        view.setUint32(40, dataSize, true);

        // Write samples
        let offset = 44;
        for (let i = 0; i < samples.length; i++) {
            const s = Math.max(-1, Math.min(1, samples[i]));
            view.setInt16(offset, s * 0x7FFF, true);
            offset += 2;
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    // â”€â”€ Ğ Ğ¸ÑĞ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²Ğ¾Ğ»Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ñ‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function drawWaveform(canvas, samples) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;

        ctx.fillStyle = '#0f3460';
        ctx.fillRect(0, 0, w, h);

        ctx.strokeStyle = '#3282b8';
        ctx.lineWidth = 1;
        ctx.beginPath();

        const step = Math.ceil(samples.length / w);
        for (let x = 0; x < w; x++) {
            const idx = x * step;
            let min = 0, max = 0;
            for (let j = 0; j < step && idx + j < samples.length; j++) {
                const s = samples[idx + j];
                if (s < min) min = s;
                if (s > max) max = s;
            }
            const y1 = (1 - max) / 2 * h;
            const y2 = (1 - min) / 2 * h;
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
        }
        ctx.stroke();
    }

    // â”€â”€ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const container = document.getElementById('audio');

    for (const sound of SOUNDS) {
        const item = document.createElement('div');
        item.className = 'audio-item';
        item.dataset.name = sound.name;

        const category = document.createElement('div');
        category.className = 'category';
        category.textContent = sound.category;
        item.appendChild(category);

        const title = document.createElement('h3');
        const ext = document.querySelector('input[name="format"]:checked')?.value || 'wav';
        title.textContent = sound.name + '.' + ext;
        item.appendChild(title);

        const row = document.createElement('div');
        row.className = 'audio-row';

        // Canvas Ğ´Ğ»Ñ Ğ²Ğ¾Ğ»Ğ½Ñ‹
        const canvas = document.createElement('canvas');
        canvas.className = 'waveform';
        canvas.width = 120;
        canvas.height = 40;
        row.appendChild(canvas);

        // ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ²Ğ¾ÑĞ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²ĞµĞ´ĞµĞ½Ğ¸Ñ
        const playBtn = document.createElement('button');
        playBtn.className = 'play-btn';
        playBtn.textContent = 'â–¶';
        playBtn.onclick = () => {
            const samples = generateSoundBuffer(sound);
            if (samples) playSamples(samples, 0.5);
        };
        row.appendChild(playBtn);

        // ĞšĞ½Ğ¾Ğ¿ĞºĞ° ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save';
        saveBtn.onclick = () => downloadSound(sound);
        row.appendChild(saveBtn);

        item.appendChild(row);
        container.appendChild(item);

        // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ñ€Ğ¸ÑÑƒĞµĞ¼ Ğ²Ğ¾Ğ»Ğ½Ñƒ
        const samples = generateSoundBuffer(sound);
        if (samples) drawWaveform(canvas, samples);
    }

    // â”€â”€ Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ²ÑƒĞºĞ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function downloadSound(sound) {
        const samples = generateSoundBuffer(sound);
        if (!samples) return;

        const blob = samplesToWav(samples);
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.download = sound.name.split('/').pop() + '.wav';
        link.href = url;
        link.click();

        URL.revokeObjectURL(url);
    }

    // â”€â”€ Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ·Ğ²ÑƒĞºĞ¾Ğ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window.downloadAll = async function() {
        const progress = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        progress.style.display = 'block';

        const zip = new JSZip();

        for (let i = 0; i < SOUNDS.length; i++) {
            const sound = SOUNDS[i];
            const samples = generateSoundBuffer(sound);

            if (samples) {
                const blob = samplesToWav(samples);
                const arrayBuffer = await blob.arrayBuffer();
                zip.file(sound.name + '.wav', arrayBuffer);
            }

            const pct = ((i + 1) / SOUNDS.length * 100) | 0;
            progressBar.style.width = pct + '%';
            progressText.textContent = `Generating: ${sound.name} (${pct}%)`;

            // Ğ”Ğ°Ñ‘Ğ¼ Ğ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ñƒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ UI
            await new Promise(r => setTimeout(r, 10));
        }

        progressText.textContent = 'Creating ZIP...';

        const content = await zip.generateAsync({ type: 'blob' });

        const link = document.createElement('a');
        link.download = 'audio.zip';
        link.href = URL.createObjectURL(content);
        link.click();

        progress.style.display = 'none';
    };

    // â”€â”€ ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ·Ğ²ÑƒĞºĞ¾Ğ² â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    window.playAllPreview = async function() {
        for (const sound of SOUNDS) {
            const samples = generateSoundBuffer(sound);
            if (samples) {
                playSamples(samples, 0.3);
                await new Promise(r => setTimeout(r, 400));
            }
        }
    };
</script>
</body>
</html>