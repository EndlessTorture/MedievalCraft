<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Export Textures</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        .texture-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .texture-item {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
        }
        .texture-item h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #0f4c75;
        }
        .texture-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .texture-row canvas {
            border: 2px solid #333;
            image-rendering: pixelated;
        }
        .texture-row span {
            font-size: 12px;
            color: #888;
        }
        button {
            background: #3282b8;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
        }
        button:hover { background: #0f4c75; }
        .download-all {
            background: #27ae60;
            font-size: 18px;
            padding: 15px 30px;
        }
        .instructions {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
<h1>ðŸŽ¨ Texture Exporter</h1>

<div class="instructions">
    <h3>Instructions:</h3>
    <ol>
        <li>Click "Download All Textures" to get a ZIP with all textures</li>
        <li>Or click individual "Save" buttons to download specific textures</li>
        <li>Place the textures in <code>assets/textures/blocks/</code> folder</li>
    </ol>
</div>

<button class="download-all" onclick="downloadAll()">ðŸ“¦ Download All Textures (ZIP)</button>

<div id="textures" class="texture-grid"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script type="module">
    // â”€â”€ Ð£Ñ‚Ð¸Ð»Ð¸Ñ‚Ñ‹ Ð´Ð»Ñ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function hashRand(x, y, s = 0) {
        let h = (x*374761393 + y*668265263 + s*1274126177) ^ (x*y*s + 12345);
        h = ((h >> 16) ^ h) * 0x45d9f3b;
        h = ((h >> 16) ^ h) * 0x45d9f3b;
        h = (h >> 16) ^ h;
        return (h & 0xFFFF) / 0xFFFF;
    }

    function smoothNoise(x, y) {
        const xi = Math.floor(x), yi = Math.floor(y);
        const xf = x - xi, yf = y - yi;
        const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
        const lerp = (a, b, t) => a + t * (b - a);
        const r00 = hashRand(xi, yi, 77) * 2 - 1;
        const r10 = hashRand(xi+1, yi, 77) * 2 - 1;
        const r01 = hashRand(xi, yi+1, 77) * 2 - 1;
        const r11 = hashRand(xi+1, yi+1, 77) * 2 - 1;
        return lerp(lerp(r00, r10, fade(xf)), lerp(r01, r11, fade(xf)), fade(yf));
    }

    const T = {
        hashRand,
        smoothNoise,

        addNoise(pixels, amount, seed = 0) {
            for (let y = 0; y < 16; y++)
                for (let x = 0; x < 16; x++) {
                    const n = smoothNoise((x + seed*100)*.3, (y + seed*50)*.3) * amount;
                    const i = (y * 16 + x) * 4;
                    pixels[i] = Math.max(0, Math.min(255, pixels[i] + n));
                    pixels[i+1] = Math.max(0, Math.min(255, pixels[i+1] + n));
                    pixels[i+2] = Math.max(0, Math.min(255, pixels[i+2] + n));
                }
            return pixels;
        },

        fill(pixels, r, g, b, a = 255) {
            for (let i = 0; i < 16*16*4; i += 4) {
                pixels[i]=r; pixels[i+1]=g; pixels[i+2]=b; pixels[i+3]=a;
            }
            return pixels;
        },

        put(pixels, x, y, r, g, b, a = 255) {
            if (x < 0 || x >= 16 || y < 0 || y >= 16) return;
            const i = (y * 16 + x) * 4;
            pixels[i]=r; pixels[i+1]=g; pixels[i+2]=b; pixels[i+3]=a;
        },

        get(pixels, x, y) {
            if (x < 0 || x >= 16 || y < 0 || y >= 16) return [0,0,0,255];
            const i = (y * 16 + x) * 4;
            return [pixels[i], pixels[i+1], pixels[i+2], pixels[i+3]];
        },

        blank() { return new Uint8Array(16 * 16 * 4); },
    };

    // â”€â”€ Ð’ÑÐµ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const grassTop = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n = T.hashRand(x,y,1);
            let g=80+n*50, r=40+n*20, b=20+n*15;
            if (T.hashRand(x,y,7)<.15) { g+=30; r-=10; }
            T.put(px,x,y,r,g,b);
        }
        T.addNoise(px,15,1);
    };

    const dirtTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,4);
            T.put(px,x,y,110+n*30,80+n*20,50+n*15);
            if (T.hashRand(x,y,99)<.08) T.put(px,x,y,90,65,35);
        }
        T.addNoise(px,12,1);
    };

    const grassSide = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,3);
            if (y<3) T.put(px,x,y,40+n*15,70+n*50,20+n*10);
            else     T.put(px,x,y,110+n*30,80+n*20,50+n*15);
        }
        T.addNoise(px,15,2);
    };

    const stoneTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,5), n2=T.smoothNoise(x*.4,y*.4)*.5+.5;
            const v=100+n*30+n2*25; T.put(px,x,y,v,v-2,v-5);
        }
        for (let i=0;i<3;i++) {
            let sx=T.hashRand(i,0,55)*14+1|0, sy=T.hashRand(i,1,55)*14+1|0;
            for (let j=0;j<4;j++) {
                T.put(px,sx,sy,70,68,65);
                sx+=(T.hashRand(i,j,66)*3-1)|0;
                sy+=(T.hashRand(i,j,77)*3-1)|0;
            }
        }
        T.addNoise(px,10,2);
    };

    const woodTop = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const d=Math.sqrt((x-8)**2+(y-8)**2), ring=Math.sin(d*1.5)*.5+.5, v=130+ring*40;
            T.put(px,x,y,v,v*.7,v*.4);
        }
        T.addNoise(px,8,3);
    };

    const woodSide = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const bark=Math.sin(x*.8+T.smoothNoise(x*.3,y*.2)*3)*.5+.5, n=T.hashRand(x,y,8), v=100+bark*35+n*15;
            T.put(px,x,y,v,v*.65,v*.35);
        }
        for (let x=0;x<16;x+=(3+(T.hashRand(x,0,11)*2|0)))
            for (let y=0;y<16;y++) if (T.hashRand(x,y,12)<.4) {
                const c=T.get(px,x,y); T.put(px,x,y,c[0]*.8,c[1]*.8,c[2]*.8);
            }
        T.addNoise(px,8,3);
    };

    const leavesTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,9), n2=T.smoothNoise(x*.5,y*.5)*.5+.5;
            T.put(px,x,y,25+n*20,60+n*40+n2*30,20+n*10);
        }
        T.addNoise(px,15,4);
    };

    const sandTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,10), v=200+n*40;
            T.put(px,x,y,v,v*.9,v*.6);
            if (T.hashRand(x,y,44)<.05) T.put(px,x,y,180,170,110);
        }
        T.addNoise(px,10,5);
    };

    const waterTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.smoothNoise(x*.3,y*.3)*.5+.5;
            T.put(px,x,y,20+n*20,50+n*30,140+n*40,180);
        }
    };

    const cobbleTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,13), v=90+n*40; T.put(px,x,y,v,v-3,v-5);
        }
        for (let i=0;i<6;i++) {
            const bx=T.hashRand(i,0,14)*14+1|0, by=T.hashRand(i,1,14)*14+1|0, s=T.hashRand(i,2,14)*3+2|0;
            for (let dy=-s;dy<=s;dy++) for (let dx=-s;dx<=s;dx++) if (dx*dx+dy*dy<s*s) {
                const c=T.get(px,bx+dx,by+dy), sh=T.hashRand(i,3,14)*20-10;
                T.put(px,bx+dx,by+dy,c[0]+sh,c[1]+sh,c[2]+sh);
            }
            for (let a=0;a<Math.PI*2;a+=.3) {
                const cx=bx+Math.cos(a)*s|0, cy=by+Math.sin(a)*s|0;
                const c=T.get(px,cx,cy); T.put(px,cx,cy,c[0]*.7,c[1]*.7,c[2]*.7);
            }
        }
        T.addNoise(px,8,6);
    };

    const planksTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,15), v=160+n*25+(y/4|0)%2*10, line=y%4===0?.7:1;
            T.put(px,x,y,v*line,v*.72*line,v*.42*line);
        }
        for (let p=0;p<4;p++) T.put(px,T.hashRand(p,0,16)*12+2|0,p*4+2,60,55,50);
        T.addNoise(px,8,7);
    };

    const makeOreTex = (oreR, oreG, oreB, seed) => (px) => {
        stoneTex(px);
        for (let i=0;i<5;i++) {
            const cx=T.hashRand(i,0,seed)*12+2|0, cy=T.hashRand(i,1,seed)*12+2|0;
            for (let dy=-1;dy<=1;dy++) for (let dx=-1;dx<=1;dx++)
                if (T.hashRand(i+dx,dy,seed)<.65)
                    T.put(px,cx+dx,cy+dy,oreR,oreG,oreB);
        }
        T.addNoise(px,8,seed);
    };

    const brickTex = (px) => {
        T.fill(px,140,75,55);
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,23), row=y/4|0, off=(row%2)*4;
            if (y%4===0||(x+off)%8===0) T.put(px,x,y,170+n*20,165+n*15,150+n*10);
            else { const v=140+n*30; T.put(px,x,y,v,v*.5,v*.35); }
        }
        T.addNoise(px,10,11);
    };

    const snowTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,24), v=230+n*25;
            T.put(px,x,y,v,v,Math.min(255,v+5));
        }
        T.addNoise(px,5,12);
    };

    const gravelTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,25), v=100+n*50; T.put(px,x,y,v,v-3,v-8);
        }
        T.addNoise(px,15,13);
    };

    const glassTex = (px) => {
        T.fill(px,200,220,235,50);
        for (let i=0;i<16;i++) {
            T.put(px,i,0,180,200,210,220); T.put(px,i,15,180,200,210,220);
            T.put(px,0,i,180,200,210,220); T.put(px,15,i,180,200,210,220);
        }
        for (let i=0;i<5;i++) { T.put(px,2+i,2,255,255,255,100); T.put(px,2,2+i,255,255,255,80); }
    };

    const bedRockTex = (px) => {
        for (let y=0;y<16;y++) for (let x=0;x<16;x++) {
            const n=T.hashRand(x,y,27), v=30+n*30; T.put(px,x,y,v,v,v);
        }
        T.addNoise(px,10,14);
    };

    const bookshelfSide = (px) => {
        T.fill(px,140,110,70);
        let bx=1;
        while (bx<15) {
            const bw=1+(T.hashRand(bx,0,28)*2|0);
            const palettes=[
                [120+T.hashRand(bx,1,28)*60,30+T.hashRand(bx,2,28)*40,30],
                [30,60+T.hashRand(bx,3,28)*60,30+T.hashRand(bx,4,28)*40],
                [30+T.hashRand(bx,5,28)*40,30,100+T.hashRand(bx,6,28)*60],
                [130+T.hashRand(bx,7,28)*40,100+T.hashRand(bx,8,28)*30,30],
            ];
            const col=palettes[T.hashRand(bx,9,28)*4|0];
            for (let shelf=0;shelf<2;shelf++) {
                const sy=shelf*8+1;
                for (let dy=0;dy<6;dy++) for (let dx=0;dx<bw;dx++) T.put(px,bx+dx,sy+dy,...col);
            }
            bx+=bw+1;
        }
        for (let x=0;x<16;x++) {
            T.put(px,x,0,100,75,40); T.put(px,x,8,100,75,40);
            T.put(px,x,7,90,65,35);  T.put(px,x,15,100,75,40);
        }
        T.addNoise(px,8,15);
    };

    const tallGrassTex = (px) => {
        for (let s=0;s<3;s++) {
            let bx=4+s*4+(T.hashRand(s,0,111)*3-1|0);
            for (let y=15;y>=4;y--) {
                const sway=Math.sin((15-y)*.3+s)*1.5, cx=bx+sway|0, n=T.hashRand(cx,y,s*7);
                T.put(px,cx,y,40+n*20,90+n*50,20+n*15);
                if (cx+1<16) T.put(px,cx+1,y,35+n*15,80+n*40,18+n*10,200);
            }
        }
    };

    const flowerTex = (petalR, petalG, petalB, centreR, centreG, centreB) => (px) => {
        for (let y=8;y<16;y++) { T.put(px,7,y,30,80,20); T.put(px,8,y,30,80,20); }
        [[7,5],[9,5],[6,6],[10,6],[7,7],[9,7],[8,4],[8,6]].forEach(([x,y])=>{
            T.put(px,x,y,petalR,petalG,petalB);
        });
        T.put(px,8,5,centreR,centreG,centreB);
    };

    const mushroomTex = (px) => {
        for (let y=10;y<16;y++) { T.put(px,7,y,200,190,170); T.put(px,8,y,200,190,170); }
        for (let dy=-3;dy<=0;dy++) for (let dx=-3;dx<=3;dx++) if (dx*dx+dy*dy<=10) {
            T.put(px,8+dx,8+dy,180,30,30);
            if (T.hashRand(dx+3,dy+3,55)<.3) T.put(px,8+dx,8+dy,240,240,230);
        }
    };

    const torchTex = (px) => {
        for (let y=5;y<16;y++) { T.put(px,7,y,140,110,60); T.put(px,8,y,140,110,60); }
        T.put(px,7,3,255,200,50); T.put(px,8,3,255,200,50);
        T.put(px,7,4,255,150,30); T.put(px,8,4,255,150,30);
        T.put(px,8,2,255,230,100,200);
    };

    // â”€â”€ ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ñ‚ÐµÐºÑÑ‚ÑƒÑ€ Ð´Ð»Ñ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const TEXTURES = {
        'grass_top': grassTop,
        'grass_side': grassSide,
        'dirt': dirtTex,
        'stone': stoneTex,
        'wood_top': woodTop,
        'wood_side': woodSide,
        'leaves': leavesTex,
        'sand': sandTex,
        'water': waterTex,
        'cobble': cobbleTex,
        'planks': planksTex,
        'coal_ore': makeOreTex(25,25,25, 17),
        'iron_ore': makeOreTex(180,140,120, 19),
        'gold_ore': makeOreTex(220,190,40, 21),
        'brick': brickTex,
        'snow': snowTex,
        'gravel': gravelTex,
        'glass': glassTex,
        'bedrock': bedRockTex,
        'bookshelf': bookshelfSide,
        'tall_grass': tallGrassTex,
        'flower_red': flowerTex(200,20,20, 255,220,50),
        'flower_yellow': flowerTex(240,210,20, 180,120,20),
        'mushroom': mushroomTex,
        'torch': torchTex,
    };

    // â”€â”€ Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ð¸ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const container = document.getElementById('textures');
    const canvases = {};

    for (const [name, fn] of Object.entries(TEXTURES)) {
        const item = document.createElement('div');
        item.className = 'texture-item';

        const title = document.createElement('h3');
        title.textContent = name + '.png';
        item.appendChild(title);

        const row = document.createElement('div');
        row.className = 'texture-row';

        // Canvas 16x16
        const canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        canvas.style.width = '64px';
        canvas.style.height = '64px';

        const ctx = canvas.getContext('2d');
        const px = T.blank();
        fn(px);

        const imageData = new ImageData(new Uint8ClampedArray(px), 16, 16);
        ctx.putImageData(imageData, 0, 0);

        canvases[name] = canvas;

        row.appendChild(canvas);

        // ÐšÐ½Ð¾Ð¿ÐºÐ° ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ñ
        const btn = document.createElement('button');
        btn.textContent = 'Save';
        btn.onclick = () => downloadTexture(name, canvas);
        row.appendChild(btn);

        item.appendChild(row);
        container.appendChild(item);
    }

    function downloadTexture(name, canvas) {
        const link = document.createElement('a');
        link.download = name + '.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }

    window.downloadAll = async function() {
        const zip = new JSZip();
        const folder = zip.folder('blocks');

        for (const [name, canvas] of Object.entries(canvases)) {
            const dataUrl = canvas.toDataURL('image/png');
            const base64 = dataUrl.split(',')[1];
            folder.file(name + '.png', base64, { base64: true });
        }

        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.download = 'textures.zip';
        link.href = URL.createObjectURL(content);
        link.click();
    };
</script>
</body>
</html>